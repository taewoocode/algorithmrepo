package basic;

public class BinaryNumber {
    public static void main(String[] args) {

        //10진수를 2진수로 변환해야 한다.

        int inputNum = 19;

        //2진수 값들을 저장할 용도로 사용할 배열
        int[] bin = new int[100];

        //10진수를 2진수로 바꿀 때 어떻게 하냐? -> 계속 2로 나눈다.

        /**
         *
         *          * 19 / 2   9.....1
         *          * 9 / 2    4.....1
         *          * 4 / 2    2 ....0
         *          * 2 / 2    1 ....0
         *          * 1 / 2    0 ....1
         *          010011 -> 19
         */

        //bin배열의 index를 카운팅하기 위한 변수 i
        int i = 0;
        int mok = inputNum;

        //계속 2로 나누기 위해서 while을 꺼냈다. 계속 2로 나누는 행위는 반복이기 때문에 while로 나눴다.
        while (mok > 0) {
            bin[i] = mok % 2; // 2로나눈 나머지를 넣어준다. 그럼 value인 1이 0번째 인덱스에 들어간다.

            //mok = mok / 2랑 같다. mok을 2로 나눈 값을 다시 mok에 저장한다.
            mok /= 2;
            //while문이 끝나고나면 index카운팅을 다시 올려준다. -> 다음번 bin에 index를 올려서 저장을 해야하기 때문이다.
            i++;
        }
        //index에 값이 다 저장되고 나서도 i++로직은 실행되기 때문에 i--로 1만큼 뺴줘야 한다.
        i--;

        //별도의 초기화 x, 조건식: i가 0 이상일 때 까지 반복한다. 코드가 실행되고 i--로 i를 1만큼 감소시킨다.
        for (; i >= 0; i--) {
            System.out.print( bin[i] );
        }





        /**
         * 즉 핵심 알고리즘은 mok을 2로 나눈 나머지가 0번째 인덱스에 저장이 된다.
         * 그 다음 몫을 갱신해줘야 하는데 몫은 2로 나눈 값을 자기 자신에게 저장한다
         * 그 다음 다음번째 index값의 카운팅을 올려서 index[1]번째에 값을 저장해주는 방식을 이용한다.
         * 즉 핵심 알고리즘은 나머지와 몫을 생각해서 풀이하되 while문 안에서 반복해준다.
         * 즉 반복문을 사용하는 것이 중요하다.
         * 배열선언하고 ~ , 반복문으로 순회하고 ~
         */
    }

}
